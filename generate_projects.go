// +build ignore

// This file generates project_ids.go.
// Invoke with go generate.

package main

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/cockroachlabs/blathers-bot"
	"github.com/google/go-github/v32/github"
	"golang.org/x/oauth2"
)

func main() {
	ctx := context.Background()
	file, err := ioutil.ReadFile(os.ExpandEnv("$HOME/.blathers_token"))
	if err != nil {
		panic("populate ~/.blathers_token with a personal access token")
	}
	token := strings.TrimSpace(string(file))
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: token},
	)
	tc := oauth2.NewClient(ctx, ts)
	client := github.NewClient(tc)
	ownersToRepos := make(map[string]map[string]struct{})
	for _, teamInfo := range blathers.TeamInfo {
		repos := ownersToRepos[teamInfo.Owner]
		if repos == nil {
			repos = make(map[string]struct{})
			ownersToRepos[teamInfo.Owner] = repos
		}
		if teamInfo.Repo != "" {
			repos[teamInfo.Repo] = struct{}{}
		}
	}
	var projects []*github.Project
	for owner, repos := range ownersToRepos {
		var r []*github.Project
		var resp *github.Response
		var err error
		more := true
		opts := &github.ProjectListOptions{
			ListOptions: github.ListOptions{
				PerPage: 100,
			},
		}
		for more {
			r, resp, err = client.Organizations.ListProjects(ctx, owner, opts)
			if err != nil {
				panic("error finding projects" + err.Error())
			}
			more = resp.NextPage != 0
			if more {
				opts.Page = resp.NextPage
			}
			projects = append(projects, r...)
		}
		for repo := range repos {
			opts = &github.ProjectListOptions{
				ListOptions: github.ListOptions{
					PerPage: 100,
				},
			}
			more = true
			for more {
				r, resp, err = client.Repositories.ListProjects(ctx, owner, repo, opts)
				if err != nil {
					panic("error finding projects" + err.Error())
				}
				more = resp.NextPage != 0
				if more {
					opts.Page = resp.NextPage
				}
				projects = append(projects, r...)
			}
		}
	}
	for _, proj := range projects {
		name := proj.GetName()
		for _, info := range blathers.TeamInfo {
			if info.ProjectName == name {
				info.ProjectID = proj.GetID()
			}
		}
	}

	projectNameToTeam := make(map[string]string)
	for name, info := range blathers.TeamInfo {
		projectNameToTeam[info.ProjectName] = name
	}

	for _, proj := range projects {
		name, ok := projectNameToTeam[proj.GetName()]
		if !ok {
			continue
		}
		fmt.Println("Fetching proj cols for ", proj.GetName())
		cols, r, err := client.Projects.ListProjectColumns(ctx, proj.GetID(), &github.ListOptions{PerPage: 100})
		if err != nil {
			panic("error finding project columns" + err.Error())
		}
		if r.NextPage != 0 {
			panic("too many columns in project " + proj.GetName())
		}
		info := blathers.TeamInfo[name]
		info.ProjectID = proj.GetID()
		for _, col := range cols {
			if col.GetName() == info.TriageColumn {
				info.TriageColumnID = col.GetID()
				break
			}
		}
	}

	// Emit project id to name map.
	var b bytes.Buffer
	fmt.Fprintln(&b, `
// Code generated by go generate; DO NOT EDIT.
package blathers

func init() {
	var info *teamInfo
`)
	for name, info := range blathers.TeamInfo {
		fmt.Fprintf(&b, "\tinfo = TeamInfo[\"%s\"]\n", name)
		fmt.Fprintf(&b, "\tinfo.TriageColumnID = %d\n", info.TriageColumnID)
		fmt.Fprintf(&b, "\tinfo.ProjectID = %d\n", info.ProjectID)
	}
	fmt.Fprintln(&b, "}")

	ioutil.WriteFile("project_ids.go", b.Bytes(), 0666)
}
